import os
import csv
import webbrowser
from datetime import datetime
from typing import List, Tuple
from models.expense_manager import ExpenseManager
from utils.visualizer import generate_graph_html

# Generated By AI (Gemini) after detailed instructions from me
# Mostly generated by AI but I had to do changes to the functions where I needed output as per my naming convention
# Final pass by AI to fix bugs and make it a bit cleaner

def create_artifact_folder(output_root="artifacts"):
    """Creates a timestamped folder and returns the path."""
    now = datetime.now()
    folder_name = os.path.join(output_root, f"run_{now.strftime('%Y-%m-%d_%H-%M-%S')}")
    os.makedirs(folder_name, exist_ok=True)
    return folder_name

def export_original_state(folder_path: str, manager: ExpenseManager, num_users: int, num_transactions: int):
    """
    Exports the initial state of the graph (Before Optimization).
    """
    print(f"Exporting Original State to {folder_path}...")
    
    # 1. Export Original Transactions
    tx_path = os.path.join(folder_path, f"transactions_original_{num_users}_{num_transactions}.csv")
    with open(tx_path, 'w', newline='') as f:
        w = csv.writer(f)
        w.writerow(["Payer", "Payee", "Amount"])
        for t in manager.transactions:
            w.writerow([t.payer_id, t.payee_id, f"{t.amount:.2f}"])

    # 2. Export Original Net Balances
    bal_path = os.path.join(folder_path, f"net_balances_original_{num_users}_{num_transactions}.csv")
    with open(bal_path, 'w', newline='') as f:
        w = csv.writer(f)
        w.writerow(["User", "Balance", "Status"])
        for u, b in enumerate(manager.net_balances):
            s = "Creditor" if b > 0.01 else ("Debtor" if b < -0.01 else "Neutral")
            w.writerow([u, f"{b:.2f}", s])

    # 3. Generate Original Graph
    graph_path = os.path.join(folder_path, f"graph_original_{num_users}_{num_transactions}.html")
    generate_graph_html(manager, graph_path)

def export_run_artifacts(folder_path: str, filename_suffix: str, transactions: List[Tuple], manager: ExpenseManager):
    """
    Exports CSV and HTML for a specific run (e.g., 'max_max').
    """
    # 1. Export Transactions CSV
    csv_name = f"transactions_{filename_suffix}.csv"
    with open(os.path.join(folder_path, csv_name), 'w', newline='') as f:
        w = csv.writer(f)
        w.writerow(["Payer", "Payee", "Amount"])
        for t in transactions:
            w.writerow([t[0], t[1], f"{t[2]:.2f}"])

    # 2. Generate HTML Graph
    # We need to create a temporary manager object that holds THESE transactions
    # so the visualizer can render them correctly.
    temp_mgr = ExpenseManager(manager.num_users)
    # Copy the node balances (structure of the graph)
    temp_mgr.net_balances = list(manager.net_balances) 
    
    # Rebuild transaction objects for visualizer
    from models.transaction import Transaction
    for payer, payee, amt in transactions:
        temp_mgr.transactions.append(Transaction(payer, payee, amt))
        
    html_name = f"graph_{filename_suffix}.html"
    generate_graph_html(temp_mgr, os.path.join(folder_path, html_name))

def export_benchmark_stats(folder_path: str, stats: List[dict], active_balances: dict):
    """
    Exports the comparison table to CSV.
    """
    # 1. Calculate Bounds
    # Filter strictly active users (non-zero) just to be safe
    debtors = [u for u, b in active_balances.items() if b < -0.001]
    creditors = [u for u, b in active_balances.items() if b > 0.001]
    n_active = len(active_balances)
    
    # Theoretical Best: Max of Debtors or Creditors count
    # (Everyone must pay at least once, or receive at least once)
    floor = max(len(debtors), len(creditors))
    
    # Theoretical Worst: Spanning Tree (N - 1)
    ceiling = max(0, n_active - 1)
    
    path = os.path.join(folder_path, "benchmark_stats.csv")
    with open(path, 'w', newline='') as f:
        w = csv.writer(f)
        w.writerow(["Algorithm", "Transactions", "Time (s)", "Gap from Floor"])
        
        # 2. Write Theoretical Rows first
        w.writerow(["Theoretical Best (Lower Bound)", floor, "0.0000", "0"])
        w.writerow(["Theoretical Worst (Upper Bound)", ceiling, "0.0000", ceiling - floor])
        
        # 3. Write Algorithm Rows
        for s in stats:
            count = s['count']
            time_val = s['time']
            
            # If count is 0 (Skipped), gap is undefined/irrelevant, effectively infinite or N/A
            if count == 0:
                gap = "N/A"
            else:
                gap = count - floor
                
            w.writerow([s['name'], count, f"{time_val:.4f}", gap])