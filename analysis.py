import os
import csv
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import glob
import numpy as np
import plotly.express as px
import plotly.graph_objects as go

# Generated by AI (Gemini) with my collaboration

# ==========================================
# 1. CONFIGURATION
# ==========================================
ARTIFACTS_PATH = r"D:\CMU\Mini 2\Financial Computing\fc2-final-project-Anmaya1856\artifacts"
OUTPUT_PATH = r"D:\CMU\Mini 2\Financial Computing\fc2-final-project-Anmaya1856\analysis_results"

os.makedirs(OUTPUT_PATH, exist_ok=True)

# Set global plot style for Static Graphs
sns.set_theme(style="whitegrid", context="talk")
plt.rcParams["figure.figsize"] = (16, 10)
plt.rcParams["font.size"] = 16 

# Custom Color Palette
COLOR_MAP = {
    # "Exact MILP": "#1f77b4",          
    "Exact MILP Gurobi": "#1f77b4",
    "Layered Solver k4": "#ffbb78",   
    "Layered Solver": "#ff7f0e",      
    "Hybrid Greedy Monte Carlo": "#2ca02c",
    "Max-Max Greedy": "#d62728",      
    "Min-Min Greedy": "#9467bd",      
}

# --- CUSTOM ORDERING HELPER ---
PREFERRED_ORDER = [
    "Exact MILP Gurobi", 
    # "Exact MILP",
    "Layered Solver k4", 
    "Layered Solver",
    "Hybrid Greedy Monte Carlo",
    "Max-Max Greedy", 
    "Min-Min Greedy"
]

def get_algo_order(df):
    unique_algos = set(df['Algorithm'].unique())
    sorted_algos = [a for a in PREFERRED_ORDER if a in unique_algos]
    leftovers = sorted(list(unique_algos - set(sorted_algos)))
    return sorted_algos + leftovers

# ==========================================
# 2. DATA LOADING
# ==========================================

def parse_benchmark_file(filepath):
    metadata = {}
    algo_data_temp = []
    try:
        with open(filepath, 'r', newline='', encoding='utf-8', errors='replace') as f: 
            reader = csv.reader(f)
            rows = list(reader)
        if not rows: return None

        for row in rows[:20]:
            if len(row) < 2: continue
            key = row[0].strip()
            val = row[1].strip()
            if "Active Users" in key and val.isdigit(): metadata['N'] = int(val)
            elif "Theoretical Min" in key and val.isdigit(): metadata['Floor'] = int(val)
            elif "Theoretical Worst" in key and val.isdigit(): metadata['Ceiling'] = int(val)

        header_idx = -1
        for i, row in enumerate(rows):
            if len(row) > 0 and "Algorithm" in row[0]:
                header_idx = i; break
        if header_idx == -1: return None
        
        for row in rows[header_idx+1:]:
            if not row or not row[0]: continue
            algo_name = row[0].strip()
            try:
                txs = int(float(row[1]))
                time_val = float(row[2])
            except ValueError: continue

            if "Theoretical Worst" in algo_name:
                if 'N' not in metadata: metadata['N'] = txs + 1
                if 'Ceiling' not in metadata: metadata['Ceiling'] = txs
                continue
            if "Theoretical Best" in algo_name:
                if 'Floor' not in metadata: metadata['Floor'] = txs
                continue

            algo_data_temp.append({
                'Algorithm': algo_name,
                'Transactions': txs,
                'Time (s)': time_val
            })

        if 'N' not in metadata: return None

        final_data = []
        for item in algo_data_temp:
            item['N'] = metadata['N']
            item['Theoretical_Floor'] = metadata.get('Floor', 0)
            item['Optimality Gap'] = max(0, item['Transactions'] - item['Theoretical_Floor'])
            final_data.append(item)
        return final_data
    except Exception: return None

def load_data(root_path):
    all_records = []
    files = glob.glob(os.path.join(root_path, "**", "benchmark_stats.csv"), recursive=True)
    print(f"Found {len(files)} benchmark files. Parsing...")
    for f in files:
        data = parse_benchmark_file(f)
        if data: all_records.extend(data)
    if not all_records: return pd.DataFrame()
    df = pd.DataFrame(all_records)
    df = df[df['N'] > 0] 
    return df

# ==========================================
# 3. STATIC PLOTTING
# ==========================================

def add_labels(ax, format_str='{:.1f}', size=16):
    for container in ax.containers:
        ax.bar_label(container, fmt=format_str, padding=5, fontsize=size, fontweight='bold')

def plot_static_transactions(df):
    plot_df = df[df['Transactions'] > 0]
    unique_ns = sorted(plot_df['N'].unique())
    for n in unique_ns:
        subset = plot_df[plot_df['N'] == n]
        if len(subset) == 0: continue
        
        plt.figure(figsize=(16, 10))
        floor = subset['Theoretical_Floor'].mean() 
        order = get_algo_order(subset)
        
        ax = sns.barplot(
            data=subset, x='Algorithm', y='Transactions', hue='Algorithm', 
            palette="viridis", estimator=np.mean, errorbar=None, dodge=False, zorder=3,
            order=order, hue_order=order
        )
        
        # INCREASED DATA LABEL FONT
        add_labels(ax, '{:.1f}', size=18)
        
        plt.axhline(floor, color='red', linestyle='--', linewidth=2.5, label=f'Theoretical Floor ({floor:.1f})', zorder=4)
        
        k_trials = len(subset) // len(subset['Algorithm'].unique())
        plt.title(f"Mean Transactions (N={n}) | Trials: k={k_trials}", fontsize=24, fontweight='bold', y=1.15)
        
        # INCREASED AXIS LABEL FONTS
        plt.ylabel("Number of Transactions", fontsize=20)
        plt.xlabel("") # Algorithm labels are on x-axis ticks
        
        # INCREASED LEGEND FONT
        plt.legend(loc='lower center', bbox_to_anchor=(0.5, 1.02), ncol=3, frameon=False, fontsize=16)
        
        # INCREASED TICK FONTS
        plt.xticks(rotation=30, ha='right', fontsize=16)
        plt.yticks(fontsize=16)
        
        plt.grid(True, axis='y', linestyle='--', alpha=0.7, zorder=0)
        plt.tight_layout()
        plt.savefig(f"{OUTPUT_PATH}/static_transactions_N{n}.png", dpi=300, bbox_inches='tight')
        plt.close()

def plot_static_time(df):
    if len(df['N'].unique()) < 2: return
    plot_df = df[df['Transactions'] > 0].copy()
    plot_df['Time (s)'] = plot_df['Time (s)'].replace(0, 0.0001)
    
    order = get_algo_order(plot_df)
    
    plt.figure(figsize=(16, 10))
    sns.lineplot(
        data=plot_df, x='N', y='Time (s)', hue='Algorithm', style='Algorithm', 
        markers=True, dashes=True, linewidth=3, markersize=10, palette="tab10", 
        errorbar=("ci", 95), hue_order=order, style_order=order
    )
    plt.yscale('log')
    plt.title("Time Complexity vs Input Size (Log Scale)", fontsize=20, fontweight='bold', y=1.15)
    plt.ylabel("Time (Seconds) - Log Scale", fontsize=15)
    plt.xlabel("Number of Active Users (N)", fontsize=15)
    plt.legend(loc='lower center', bbox_to_anchor=(0.5, 1.02), ncol=3, frameon=False, title="")
    plt.grid(True, which="both", ls="-", alpha=0.2)
    plt.tight_layout()
    plt.savefig(f"{OUTPUT_PATH}/static_time_complexity.png", dpi=300, bbox_inches='tight')
    plt.close()

def plot_static_heatmap(df):
    plot_df = df[df['Transactions'] > 0]
    pivot = plot_df.pivot_table(index='N', columns='Algorithm', values='Optimality Gap', aggfunc='mean')
    if pivot.empty: return

    order = get_algo_order(plot_df)
    valid_order = [c for c in order if c in pivot.columns]
    pivot = pivot[valid_order]

    pivot.sort_index(ascending=True, inplace=True)

    plt.figure(figsize=(14, max(8, 6 + len(pivot)*0.6)))
    row_max = pivot.max(axis=1); row_max[row_max == 0] = 1 
    norm_pivot = pivot.div(row_max, axis=0)
    
    sns.heatmap(norm_pivot, annot=pivot, cmap="Reds", fmt=".1f", linewidths=.5, annot_kws={"size": 12, "weight": "bold"}, cbar_kws={'label': 'Relative Gap'}, yticklabels=True)
    plt.title("Optimality Gap Heatmap\n(Text: Avg Extra Transactions | Color: Relative to Worst in Row)", fontsize=20, fontweight='bold', pad=20)
    plt.ylabel("Active Users (N)", fontsize=15); plt.xlabel("Algorithm", fontsize=15)
    plt.tight_layout()
    plt.savefig(f"{OUTPUT_PATH}/static_optimality_gap_heatmap.png", dpi=300, bbox_inches='tight')
    plt.close()

def plot_static_tradeoff(df):
    """Static Scatter Plot"""
    agg = df.groupby(['N', 'Algorithm']).mean().reset_index()
    order = get_algo_order(df)
    
    plt.figure(figsize=(16, 10))
    sns.scatterplot(data=agg, x='Time (s)', y='Optimality Gap', hue='Algorithm', style='Algorithm', s=200, palette="deep", alpha=0.8, hue_order=order, style_order=order)
    plt.xscale('log')
    plt.title("Cost-Benefit Analysis: Speed vs Accuracy", fontsize=20, fontweight='bold', y=1.15)
    plt.legend(loc='lower center', bbox_to_anchor=(0.5, 1.02), ncol=3, frameon=False, title="")
    plt.grid(True, which="both", ls="-", alpha=0.2); plt.tight_layout()
    plt.savefig(f"{OUTPUT_PATH}/static_tradeoff_scatter.png", dpi=300, bbox_inches='tight'); plt.close()


# ==========================================
# 4. INTERACTIVE PLOTTING (Plotly)
# ==========================================

def generate_interactive_dashboard(df):
    print("Generating Interactive Dashboard...")
    
    # 1. Time Chart
    time_df = df.groupby(['N', 'Algorithm'])['Time (s)'].mean().reset_index()
    time_df['Time (s)'] = time_df['Time (s)'].replace(0, 0.0001)
    
    fig_time = px.line(
        time_df, x='N', y='Time (s)', color='Algorithm', markers=True,
        title="<b>1. Time Complexity (Speed)</b><br><i>Logarithmic Scale</i>",
        color_discrete_map=COLOR_MAP
    )
    fig_time.update_yaxes(type="log", tickvals=[0.0001, 0.001, 0.01, 0.1, 1, 10, 60], ticktext=["0.1ms", "1ms", "10ms", "100ms", "1s", "10s", "1m"])
    fig_time.update_layout(height=600, font=dict(size=14))

    # 2. Heatmap
    pivot = df.pivot_table(index='N', columns='Algorithm', values='Optimality Gap', aggfunc='mean')
    pivot.sort_index(ascending=True, inplace=True)
    order = get_algo_order(df)
    valid_cols = [c for c in order if c in pivot.columns]
    pivot = pivot[valid_cols]
    row_max = pivot.max(axis=1); row_max[row_max == 0] = 1
    norm_pivot = pivot.div(row_max, axis=0)
    
    fig_heat = go.Figure(data=go.Heatmap(
        z=norm_pivot.values, x=pivot.columns, y=pivot.index,
        text=pivot.values, texttemplate="%{text:.1f}", textfont={"size": 16},
        colorscale="Reds", colorbar=dict(title="Relative Gap"),
    ))
    fig_heat.update_layout(
        title="<b>2. Accuracy Heatmap</b><br><i>Numbers = Avg Extra Transactions vs Floor</i>", 
        height=800, yaxis=dict(type='category', title="Active Users (N)", autorange="reversed"),
        xaxis=dict(title="Algorithm"), font=dict(size=14)
    )

    # 3. Interactive Bar Chart (Dropdown by N)
    fig_bar = go.Figure()
    all_ns = sorted(df['N'].unique())
    
    # Store shapes in a dict to update via dropdown
    shapes_dict = {}

    for i, n in enumerate(all_ns):
        subset = df[df['N'] == n]
        if subset.empty: continue
        
        agg = subset.groupby('Algorithm')['Transactions'].mean().reset_index()
        floor = subset['Theoretical_Floor'].mean()
        
        agg['Algo_Sort_Key'] = agg['Algorithm'].apply(lambda x: PREFERRED_ORDER.index(x) if x in PREFERRED_ORDER else 999)
        agg = agg.sort_values('Algo_Sort_Key')

        # Bar Trace
        fig_bar.add_trace(go.Bar(
            x=agg['Algorithm'], y=agg['Transactions'],
            text=agg['Transactions'], texttemplate='%{text:.1f}', textposition='auto',
            name=f"N={n} Txs",
            visible=(i==0),
            marker_color=[COLOR_MAP.get(a, '#888') for a in agg['Algorithm']]
        ))
        
        # Define the Red Line SHAPE for visual span
        shapes_dict[n] = [dict(
            type="line",
            xref="paper", yref="y",
            x0=0, x1=1,
            y0=floor, y1=floor,
            line=dict(color="red", width=4, dash="dash"),
        )]

    # Initial setup
    initial_n = all_ns[0]
    initial_floor = df[df['N'] == initial_n]['Theoretical_Floor'].mean()
    
    # Dummy Trace for Legend
    fig_bar.add_trace(go.Scatter(
        x=[None], y=[None],
        mode='lines',
        line=dict(color='red', width=4, dash='dash'),
        name=f'Theoretical Floor', # Static name, value in title
        showlegend=True,
        visible=True
    ))

    # Dropdown Menu Logic
    steps = []
    for i, n in enumerate(all_ns):
        visibility = [False] * len(fig_bar.data)
        visibility[i] = True     # Show Bar for N
        visibility[-1] = True    # Keep Legend Trace
        
        floor_val = df[df['N'] == n]['Theoretical_Floor'].mean()
        
        step = dict(
            method="update",
            args=[
                {"visible": visibility}, 
                {
                    "title.text": f"<b>3. Transaction Counts for N={n}</b> (Floor: {floor_val:.1f})",
                    "shapes": shapes_dict.get(n, [])
                }
            ],
            label=str(n)
        )
        steps.append(step)

    # Add Annotation for Dropdown
    fig_bar.add_annotation(
        text="Select N:", 
        x=1.15, y=1.05, 
        xref="paper", yref="paper", 
        showarrow=False, 
        font=dict(size=14, color="black"),
        xanchor="left"
    )

    fig_bar.update_layout(
        updatemenus=[dict(active=0, buttons=steps, x=1.15, y=1, xanchor="left", yanchor="top")],
        title=dict(text=f"<b>3. Transaction Counts for N={initial_n}</b> (Floor: {initial_floor:.1f})", font=dict(size=20)),
        yaxis_title="Transactions", xaxis_title="Algorithm",
        height=700, margin=dict(r=200), # Space for legend
        legend=dict(yanchor="top", y=0.9, xanchor="left", x=1.15), # Legend far right
        shapes=shapes_dict.get(initial_n, []) # Set initial shape
    )

    # 4. Animated Tradeoff
    scatter_df = df.groupby(['N', 'Algorithm']).agg({'Time (s)': 'mean', 'Optimality Gap': 'mean'}).reset_index()
    scatter_df['Time (s)'] = scatter_df['Time (s)'].replace(0, 0.0001)
    
    fig_tradeoff = px.scatter(
        scatter_df, x="Time (s)", y="Optimality Gap", animation_frame="N", animation_group="Algorithm",
        color="Algorithm", size=[20]*len(scatter_df), log_x=True,
        range_y=[-1, scatter_df['Optimality Gap'].max() * 1.1],
        range_x=[0.00005, max(65, scatter_df['Time (s)'].max())],
        title="<b>4. Cost-Benefit Tradeoff (Animated)</b>", color_discrete_map=COLOR_MAP
    )
    fig_tradeoff.update_layout(height=700, font=dict(size=14))

    # Save HTML
    out_file = os.path.join(OUTPUT_PATH, "interactive_dashboard.html")
    with open(out_file, 'w') as f:
        f.write("<html><head><title>Benchmark Results</title></head><body>")
        f.write("<h1 style='text-align:center; font-family:sans-serif;'>Benchmark Analysis Results</h1>")
        
        # --- NEW SECTION: PARAMETER SUBTITLE ---
        f.write("<p style='text-align:center; font-family:sans-serif; font-size:16px; color:#555;'>")
        f.write("<b>Parameters:</b> Min Amount = $1 | Max Amount = $500 | Transaction Type = Integer")
        f.write("</p>")
        # ---------------------------------------

        f.write(fig_time.to_html(full_html=False, include_plotlyjs='cdn'))
        f.write("<hr>")
        f.write(fig_heat.to_html(full_html=False, include_plotlyjs=False))
        f.write("<hr>")
        f.write(fig_bar.to_html(full_html=False, include_plotlyjs=False))
        f.write("<hr>")
        f.write(fig_tradeoff.to_html(full_html=False, include_plotlyjs=False))
        f.write("</body></html>")
    
    print(f"Interactive Dashboard saved: {out_file}")

# ==========================================
# 5. AGGREGATION & MAIN
# ==========================================

def export_aggregated_stats(df):
    if df.empty: return
    agg_rules = {'Transactions': ['mean', 'min', 'max', 'std'], 'Time (s)': ['mean'], 'Optimality Gap': ['mean']}
    summary = df.groupby(['N', 'Algorithm']).agg(agg_rules)
    summary.columns = ['_'.join(col).strip() for col in summary.columns.values]
    summary = summary.reset_index()
    summary.rename(columns={'Transactions_mean': 'Avg_Transactions', 'Transactions_min': 'Min_Transactions', 'Transactions_max': 'Max_Transactions', 'Time (s)_mean': 'Avg_Time_Sec', 'Optimality Gap_mean': 'Avg_Optimality_Gap'}, inplace=True)
    cols = summary.select_dtypes([np.number]).columns; summary[cols] = summary[cols].round(4)
    summary.to_csv(os.path.join(OUTPUT_PATH, "aggregated_benchmark_stats.csv"), index=False)

if __name__ == "__main__":
    print("Reading Benchmark Data...")
    df = load_data(ARTIFACTS_PATH)
    if df.empty: print("No valid data found.")
    else:
        print(f"Loaded {len(df)} rows. N values: {sorted(df['N'].unique())}")
        
        # 1. Export CSV
        export_aggregated_stats(df)
        
        # 2. Generate Static PNGs (Only the ones you wanted)
        print("Generating Static Plots...")
        plot_static_transactions(df)
        plot_static_time(df)
        plot_static_heatmap(df)
        plot_static_tradeoff(df)
        
        # 3. Generate Interactive HTML
        generate_interactive_dashboard(df)
        
        print("\nDone.")